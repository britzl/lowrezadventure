local log = require "utils.log"
local broadcaster = require "utils.broadcaster"
local komponent = require "komponent.komponent"


local hitbox = require "adventure.components.hitbox"
local health = require "adventure.components.health"
local attack = require "adventure.components.attack"
local platypus = require "adventure.components.platypus"
local animator = require "adventure.components.animator"
local damageblink = require "adventure.components.damageblink"
local damagepushback = require "adventure.components.damagepushback"
local soundplayer = require "adventure.components.soundplayer"
local death = require "adventure.components.death"
local player = require "adventure.components.player"
local camera = require "adventure.components.camera"

local events = require "adventure.events"
local sounds = require "adventure.sounds.sounds"



local STATE_IDLE = hash("idle")
local STATE_MOVE = hash("move")
local STATE_ATTACK = hash("attack")
local STATE_DAMAGE = hash("damage")
local STATE_DEAD = hash("dead")


go.property("health", 10)

function init(self)
	log.set_enabled(true)

	self.komponent = komponent.create()
	local broadcast = broadcaster.create()
	broadcast.listen(function(id, ...)
		self.komponent.on_event(id, ...)
	end)

	-- create the components used by this enemy
	local components = {
		health = health.create(broadcast, self.health),
		hitbox = hitbox.create(broadcast, "#hitbox"),
		attack = attack.create(broadcast, 0.25),
		platypus = platypus.create(broadcast, {
			rays = { left = 3, right = 4, top = 3, bottom = 5 }
		}),
		animator = animator.create("#sprite", {
			[events.MOVE_LEFT] = hash("warrior_walk"),
			[events.MOVE_RIGHT] = hash("warrior_walk"),
			[events.ATTACK] = hash("warrior_attack"),
			[events.DEATH] = hash("explosion"),
		}),
		death = death.create(0.2),
		damageblink = damageblink.create("#sprite", 0.15),
		damagepushback = damagepushback.create(0.15, 10),
		soundplayer = soundplayer.create({
			[events.ATTACK] = sounds.SWORDSWING,
			[events.MOVE_LEFT] = sounds.FOOTSTEPS,
			[events.MOVE_RIGHT] = sounds.FOOTSTEPS,
			[events.GROUND_CONTACT] = sounds.FOOTSTEPS,
		}),
		player = player.create(broadcast),
		camera = camera.create(),
	}
	
	-- create component groups
	self.komponent.group(STATE_MOVE,
		components.player,
		components.camera,
		components.animator,
		components.hitbox,
		components.soundplayer,
		components.health,
		components.attack,
		components.platypus,
		components.damageblink,
		components.damagepushback,
		components.death)
			
	self.komponent.init()
end

function final(self)
	self.komponent.final()
end

function update(self, dt)
	self.komponent.update(dt)
	--[[if input.is_pressed(ATTACK) and not self.attacking then
		log("attack")
		self.attacking = true
		self.platypus.velocity.x = 0
		msg.post(self.attack_direction, "enable")
		self.animator.play_now(ANIM_ATTACK, function()
			self.attacking = false
			msg.post(self.attack_direction, "disable")
		end)
	end

	if not self.attacking then
		local ground_contact = self.platypus.has_ground_contact()
		if input.is_pressed(LEFT) then
			self.platypus.left(ground_contact and SPEED_GROUND or SPEED_AIR)
			self.animator.play(ground_contact and ANIM_WALK or ANIM_BLOCK)
			sprite.set_hflip("#sprite", true)
			self.camera_offset_lerp.x = -12
			self.attack_direction = "#attack_left"
		elseif input.is_pressed(RIGHT) then
			self.platypus.right(ground_contact and SPEED_GROUND or SPEED_AIR)
			self.animator.play(ground_contact and ANIM_WALK or ANIM_BLOCK)
			sprite.set_hflip("#sprite", false)
			self.camera_offset_lerp.x = 12
			self.attack_direction = "#attack_right"
		else
			self.animator.play(ground_contact and ANIM_IDLE or ANIM_BLOCK)
		end
	end
	
--]]
end

function on_message(self, message_id, message, sender)
	self.komponent.on_message(message_id, message, sender)
end

function on_input(self, action_id, action)
	self.komponent.on_input(action_id, action)
end

function on_reload(self)
    -- Add reload-handling code here
    -- Remove this function if not needed
end
