local log = require "utils.log"
local stately = require "stately.stately"
local broadcaster = require "utils.broadcaster"
local komponent = require "komponent.komponent"

local follow = require "adventure.components.follow"
local hitbox = require "adventure.components.hitbox"
local health = require "adventure.components.health"
local attack = require "adventure.components.attack"
local activator = require "adventure.components.activator"
local platypus = require "adventure.components.platypus"
local animator = require "adventure.components.animator"
local death = require "adventure.components.death"
local damageblink = require "adventure.components.damageblink"
local damagepushback = require "adventure.components.damagepushback"

local events = require "adventure.enemies.events"

go.property("awake", false)
go.property("speed", 20)
go.property("health", 2)
go.property("log_enabled", false)

local GROUP_GROUND = hash("ground")

local STATE_SLEEP = hash("sleep")
local STATE_MOVE = hash("move")
local STATE_ATTACK = hash("attack")
local STATE_DAMAGE = hash("damage")
local STATE_DEAD = hash("dead")


function init(self)
	print("log enabled", self.log_enabled)
	log.set_enabled(self.log_enabled)
	log("init()")

	-- create event broadcaster
	local broadcast = broadcaster.create()
	local triggers = broadcast.create_triggers(events)
		
	-- create components
	local components = {
		activator = activator.create(triggers.WAKEUP, hash("activator")),
		hitbox = hitbox.create(triggers.HIT, triggers.DEATH, "#hitbox"),
		health = health.create(triggers.DEATH, triggers.DAMAGE, triggers.ALIVE, self.health),
		follow = follow.create(triggers.MOVE_LEFT, triggers.MOVE_RIGHT, "player", self.speed),
		attack = attack.create(triggers.ATTACK, 8, 0.75, 0.75),
		platypus = platypus.create({
			collisions = {
				ground = { GROUP_GROUND },
				left = 3, right = 4, top = 3, bottom = 5,
			},
			gravity = -800,
			max_velocity = 600,
			separation = platypus.SEPARATION_SHAPES,
		}),
		animator = animator.create("#sprite", {
			[events.WAKEUP] = hash("slime_walk"),
			[events.MOVE_LEFT] = hash("slime_walk"),
			[events.MOVE_RIGHT] = hash("slime_walk"),
			[events.ATTACK] = hash("slime_attack"),
			[events.DEATH] = hash("explosion"),
		}),
		death = death.create(0.2),
		damageblink = damageblink.create("#sprite", 0.15),
		damagepushback = damagepushback.create(0.15, 10),
	}

	-- create quilts (component groups)
	self.komponent = komponent.create()
	self.komponent.group(STATE_SLEEP, components.animator, components.activator, components.hitbox, components.health)
	self.komponent.group(STATE_MOVE, components.animator, components.follow, components.hitbox, components.health, components.attack, components.platypus)
	self.komponent.group(STATE_ATTACK, components.animator, components.hitbox, components.health)
	self.komponent.group(STATE_DAMAGE, components.animator, components.hitbox, components.health, components.damageblink, components.damagepushback)
	self.komponent.group(STATE_DEAD, components.animator, components.death)

	
	-- create state machine
	local fsm = stately.create()
	local states = {
		SLEEP = fsm.state(STATE_SLEEP),
		MOVE = fsm.state(STATE_MOVE),
		ATTACK = fsm.state(STATE_ATTACK),
		DAMAGE = fsm.state(STATE_DAMAGE),
		DEAD = fsm.state(STATE_DEAD),
	}
	fsm.transition(states.SLEEP, states.MOVE, events.WAKEUP)
	fsm.transition(states.SLEEP, states.DAMAGE, events.HIT)
	fsm.transition(states.MOVE, states.DAMAGE, events.HIT)
	fsm.transition(states.ATTACK, states.DAMAGE, events.HIT)
	fsm.transition(states.DAMAGE, states.DEAD, events.DEATH)
	fsm.transition(states.DAMAGE, states.MOVE, events.ALIVE)

	fsm.on_state_change(function(from, to)
		self.komponent.change_group(to)
		log("Changing state from", from, "to", to)
	end)
		

	broadcast.listen(function(id, ...)
		fsm.handle_event(id, ...)
		self.komponent.on_event(id, ...)
	end)

	fsm.start(states.SLEEP)
end

function final(self)
	self.komponent.final()
end

function update(self, dt)
	self.komponent.update(dt)
end

function on_message(self, message_id, message, sender)
	self.komponent.on_message(message_id, message, sender)
end
